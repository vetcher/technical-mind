source: [Коллеги, вы меня огорчаете](https://habr.com/ru/company/oleg-bunin/blog/521582/)

Скопирую сюда кусок статьи с моими комментариями. Статья сделана с прицелом на то, что бы задуматься. А этот репозиторий нужен для того, что бы находить ответы.

Итак, опросник:  
  
1. [[go]] — #императивный или #декларативный? А в чем разница? 
	- Что я хочу оценить: знакомство с разными подходами к реализации бизнес-логики.
	- Самый популярный неправильный ответ: «Я не силен в теории». Очень жаль, что ты не силен в этой теории, _%USERNAME%_. Если бы ты был в ней силен, ты бы знал, почему некоторые вещи на _Go_ получаются очень легко и хорошо, а некоторые надо прям вымучивать.
	- Наводящие вопросы: [[sql]] — императивный или декларативный? А [[Dockerfile]]? А файл настройки _github actions_?
	- Конечно императивный. Здесь еще можно упомянуть #функциональные языки. Для императивных языков код описывает последовательность действий, которая приведет к результату. Такой формат ближе к железу и тому, как это работает в компьютере. Деларативный же подход подразумевает описание "желаемого результата", что ближе к тому, как мыслит человек.
		- Когда нужно самому сделать какую-то последовательность действий, удобнее и выгоднее пользоваться императивными языками, т.к. они дают наибольший контроль за происходящим и можно описать всю последовательность очень детально. 
		- Императивные языки отлично работают когда нужно предоставить другим пользователям свое ПО как черный ящик. Это дает больший простор для оптимизаций, т.к. не пользователь решает, как все будет работать, а разработчик. Пользователь только запрашивает итоговый результат.
1. Что такое _type switch_?  
	- Что я хочу оценить: знакомство с нашим (скудным) инструментарием работы с системой типов в #runtime.
	- Самый популярный неправильный ответ: «Я не знаю». Очень странно — информация о _type switch_ есть даже в _Go tour_.
	- Наводящие вопросы: как реализовать в _Go_ тип-сумму, который может содержать в себе значения _int64|float64|complex_? Как реализовать для такого типа метод _Add(int64)_?
2. Как сообщить компилятору, что наш тип реализует интерфейс?
	-   Что я хочу оценить: хорошо ли кандидат понимает, на чем основана концепция интерфейсов в _Go_.
	- Самый популярный неправильный ответ: «Я не знаю». Справедливости ради, именно этот вопрос редко вызывает затруднения. А когда вызывает, сам кандидат весьма этим удивлен: «Я же миллион интерфейсов написал. Как компилятор понимает, что именно я реализовал?...» Ну — он умный, компилятор. И внимательный.
	- Наводящие вопросы: что такое _duck typing_? К чему он применяется в _Go_?

  
4. Как работает _append_?  
  

-   Что я хочу оценить: знаком ли кандидат с базовыми концепциями управления памятью в _Go_. Самыми базовыми.
-   Самый популярный неправильный ответ: «Он увеличивает _capacity_». Если продолжать настойчиво спрашивать: «Как он это делает?», — кандидат довольно быстро приходит к правильному ответу. Видимо, эти подробности настолько шокирующие, что забыть их трудно.
-   Наводящие вопросы: как бы вы реализовали разреженный массив в _Go_? А без использования _map_?

  
5. Какое у _slice zero value_? Какие операции над ним возможны?  
  

-   Что я хочу оценить: помнит ли кандидат, что вообще можно делать со слайсом, и как ведут себя операции на граничных значениях. Почему это важно? «Почему это важно?» — был бы отличный вопрос для интервью, если бы я придумал, как его корректно задавать.
-   Самый популярный неправильный ответ: «Можно делать _len ()_… и _cap ()_… наверное…» Операций со слайсами существенно меньше 10. И мы все — 100% — применяем их в своей повседневной работе. Надо просто пересчитать их в уме...
-   Наводящие вопросы: каков будет результат _append([]string(nil), ""_)? А _append([]string(nil), []string(nil)..._)? А почему? А _range append([]string(nil), []string(nil)..._) как отработает?

  
6. Как устроен тип _map_?  
  

-   Что я хочу оценить: насколько интересно кандидату, как именно ложатся в память наши байтики. _Map_, возможно, самая важная из стандартных структур данных, и весьма замысловато устроенная. Она сложная, она эффективная, она обладает встроенным _race condition_ детектором… Неужели не любопытно?!
-   Самый популярный неправильный ответ: «Это хеш-таблица». Да, это хеш-таблица. Как устроена хеш-таблица?
-   Наводящие вопросы: какая _hash_-функция используется в _map_ в _Go_? Что такое _bucket_?

  
7. Каков порядок перебора _map_?  
  

-   Что я хочу оценить: понимает ли кандидат, как отражается устройство структуры данных на ее свойствах. Ну или — читал ли кандидат документацию на базовые типы и запомнил ли неочевидно-важное из нее…
-   Самый популярный неправильный ответ: «В порядке вставки». Хеш-таблица, которая сортирует элементы в порядке вставки, ага. А как в ней происходит выборка по ключу в таком случае?
-   Наводящие вопросы: как получить одно случайное значение из _map_?

  
8. Что будет, если читать из закрытого канала?  
  

-   Что я хочу оценить: читал ли кандидат документацию или сразу бросился кодить. Если читал — запомнил ли очевидно-важное.
-   Самый популярный неправильный ответ: «Вернется ошибка». Ну да, ну да… Вы помните синтаксис чтения из канала? Интересно, что синтаксис помнят почти все, но вопрос: «И как вернется ошибка?», — зачастую вводит кандидата в ступор.
-   Наводящие вопросы: сколько значений возвращает одно чтение из канала? А почему _range_-чтение из канала возвращает одно?

  
9. Что будет, если писать в закрытый канал?  
  

-   Что я хочу оценить: читал ли кандидат документацию или сразу бросился кодить. Если читал — запомнил ли очевидно-важное.
-   Самый популярный неправильный ответ: «Вернется ошибка». Да, вернется. Как она это сделает?
-   Наводящие вопросы: можно ли закрывать канал со стороны читателя? А если очень надо — как быть?

  
10. Как вы отсортируете массив структур по алфавиту по полю _Name_?  

-   Что я хочу оценить: насколько кандидат склонен к написанию «велосипедов».
-   Самый популярный неправильный ответ: «Методом пузырька». Пузырек — прекрасный алгоритм, но есть сегодня и поэффективнее. Например — _quicksort_. Не можете с ходу имплементировать _quicksort_? Так ведь и не надо!
-   Наводящие вопросы: какой стандартный пакет предназначен для сортировки любых слайсов? И заодно — как сделать из массива слайс? Отсортируется ли массив при сортировке слайса?

  
11. Что такое сериализация? Зачем она нужна?  
  

-   Что я хочу оценить: глубину осознания связи простых повседневно используемых приемов с глобальными задачами разработки.
-   Самый популярный неправильный ответ: «Для превращения бинарных данных в текстовые». Строго говоря, не всегда этот процесс можно считать сериализацией, и уж точно это не единственное её применение.
-   Наводящие вопросы: почему нельзя для сериализации какой-либо переменной просто взять дамп занимаемой ею памяти?

  
12. Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?  
  

-   Что я хочу оценить: помнит ли кандидат институтский курс информатики. А если серьезно — это золотой вопрос программистского собеседования. Если бы мне позволили, я бы задавал его первым, и 70% интервью можно было бы на этом месте заканчивать. Один мой друг, который работает в _JetBrains_, так и поступает, кстати. Так вот, связанный список — это один из базовых элементов _computer science_, и один раз узнав, как он устроен, забыть это невозможно. Если «программист» не может развернуть односвязанный список, это свидетельствует о серьёзных пробелах в базовых знаниях. И это повод насторожиться — а что еще из базового он пропустил?.
-   Самый популярный неправильный ответ: «А что такое односвязанный список?». Это такая структура данных...
-   Наводящие вопросы: какие тесты вы бы написали для своей процедуры разворачивания односвязного списка?

  
13. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?  
  

-   Что я хочу оценить: степень готовности кандидата использовать средства реализации модульной архитектуры, предлагаемые _Go_.
-   Самый популярный неправильный ответ: «Рядом с реализацией». Вариантов 2, и кандидаты выбирают, похоже, наугад. На вопрос: «Почему?» — ответить затрудняются.
-   Наводящие вопросы: что такое _tight coupling_? Почему это плохо? В каком варианте связанность слабее?

  
14. Предположим, ваша функция должна возвращать детализированные _Recoverable_ и _Fatal_ ошибки. Как это реализовано в пакете _net_? Как это надо делать в современном _Go_?  
  

-   Что я хочу оценить: насколько глубоко кандидат осмыслил эту непростую тему — обработку ошибок в _Go_.
-   Самый популярный неправильный ответ: «Я не знаю». Обработка ошибок в _Go_ одновременно и проста, и сложна. Проста потому, что в крайней степени тупа. Сложна потому, что — до недавнего времени, — любая дифференцированная обработка ошибок не была стандартизована, и каждый справлялся, как мог. Ситуация изменилась, и знать об этом — прямая обязанность ответственного разработчика.
-   Наводящие вопросы: что нового и важного в плане обработки ошибок появилось в _Go_ 1.13? А чего не появилось, хоть мы и ждали?

  
15. Главный недостаток стандартного логгера?  
  

-   Что я хочу оценить: критерии выбора кандидатом _3-party_ зависимостей для проекта. Логгер — просто самый одиозный случай, когда стандартная библиотека не предоставляет нам необходимой функциональности.
-   Самый популярный неправильный ответ: «Я не пользуюсь стандартным логгером». И никто не пользуется, сюрприз! Но почему?
-   Наводящие вопросы: каково основное применение информации из логов?

  
16. Есть ли для _Go_ хороший _orm_? Ответ обоснуйте.  
  

-   Что я хочу оценить: количество и качество усилий, которые кандидат приложил к выбору инструментов, ускоряющих и облегчающих повседневную деятельность.
-   Самый популярный неправильный ответ: «_Gorm_, вроде, неплох». Конкурирует с ответом «Я всё пишу руками». Я даже согласен с обоими ответами, но давайте обсудим подробнее — как устроен _gorm_, и почему вдруг руками.
-   Наводящие вопросы: что означает буква _M_ в аббревиатуре _ORM_? Что на эту букву _M_ есть в _gorm_? А что такое _DAL_ и зачем он нужен?

  
17. Какой у вас любимый линтер?  
  

-   Что я хочу оценить: уровень знакомства с современными практиками поддержки разработки.
-   Самый популярный неправильный ответ: «Встроенный в _Goland_». _Come on!_, там нет линтера, там — тривиальный _syntax checker_!
-   Наводящие вопросы: какое отношение линтеры имеют к _CI_? Зачем нужен _CI_ в процессе разработки?

  
18. Можно ли использовать один и тот же буфер _[]byte_ в нескольких горутинах?  
  

-   Что я хочу оценить: понимает ли кандидат принципы, по которым мы выбираем использовать общую структуру данных или локальную для горутин.
-   Самый популярный неправильный ответ: «Можно, если защитить его мьютексом». Я признаю, это плохой вопрос, недостаточно показательный. Но зачем же давать на него хоть и формально правильный, но бесполезный ответ? К сожалению, в рабочей обстановке нам тоже прилетают плохие задачи, но надо уметь адекватно на них реагировать. Адекватно — это не «Что за чушь?!», а «Сформулируйте, пожалуйста, цель», кстати.
-   Наводящие вопросы: а зачем и правда может понадобиться использовать один и тот же буфер _[]byte_ в нескольких горутинах параллельно? Что именно мы будем в нем защищать мьютексом?

  
19. Какие типы мьютексов предоставляет _stdlib_?  
  

-   Что я хочу оценить: насколько глубоко кандидат разобрался в теме конкурентного доступа к данным. Да, по второму разу, но это ключевая тема. На этот раз я захожу со стороны практики.
-   Самый популярный неправильный ответ: «Не помню». На самом деле, это ответ: «Не считаю это важным». Ну и зря!
-   Наводящие вопросы: что именно и от чего защищает мьютекс?

  
20. Что такое _lock-free_ структуры данных, и есть ли в _Go_ такие?  

-   Что я хочу оценить: насколько глубоко кандидат разобрался в теме конкурентного доступа к данным.
-   Самый популярный неправильный ответ: «Нет».
-   Наводящие вопросы: что такое _atomic_? А что такое _sync.Map_? _Sync.Map_ — _lockfree_ или нет?

  
21. Способы поиска проблем производительности на проде?  
  

-   Что я хочу оценить: степень знакомства с этой малоприятной, но постоянно возникающей задачей.
-   Самый популярный неправильный ответ: «Пишу в логи». Коллеги, да такие логи сами по себе создают проблемы производительности!
-   Наводящие вопросы: какие проблемы производительности вы знаете? Может ли быть так, что потребление ресурсов (_CPU, RAM, disk/net bandwidt_h) вполне умеренное, а пользователи жалуются на «тормоза»? А на что, собственно, жалуются пользователи, и как это связано с тем, что вы видите в системе?

  
22. Стандартный набор метрик _prometheus_ в _Go_ -программе?  
  

-   Что я хочу оценить: степень готовности использовать лучшие практики современной разработки. И дело тут не столько в самом прометее, сколько в готовности следовать за тенденциями в индустрии. Это, как ни странно, важно — сохранять тесную связь с мейнстримом.
-   Самый популярный неправильный ответ: «Я не пользуюсь прометеем». А пора бы, уже несколько лет как пора!
-   Наводящие вопросы: оставив прометей в стороне — что вообще _Go_-программа способна о себе рассказать? Метрики _runtime_ — что это, и откуда берется?

  
23. Как встроить стандартный профайлер в свое приложение?  
  

-   Что я хочу оценить: на каком уровне кандидату приходилось решать проблемы недостаточной производительности.
-   Самый популярный неправильный ответ: «Я не пользуюсь профайлером». Два варианта: или вы никогда не сталкивались с проблемами производительности, или вы по неизвестным причинам игнорируете одно из самых мощных средств борьбы с такими проблемами. И то, и другое снижает вашу ценность как кандидата, и второе сильнее первого.
-   Наводящие вопросы: а он нужен, профайлер? Что там есть вообще полезного? И почему его надо встраивать, а не запускать из-под него приложение?

  
24. _Overhead_ от стандартного профайлера?  
  

-   Что я хочу оценить: тупо — читал ли кандидат документацию. И, если читал, — что понял?
-   Самый популярный неправильный ответ: «Ну, заметный».
-   Наводящие вопросы: что такое «семплирующий профайлер» и почему это хорошо?

  
25. Почему встраивание — не наследование?  
  

-   Что я хочу оценить: общее знакомство с ООП-парадигмой и границами ее применения в _Go_.
-   Самый популярный неправильный ответ: «Наследование позволяет переопределять методы». Но, коллеги, встраивание — тоже, тоже!
-   Наводящие вопросы: Что означает буква _L_ в аббревиатуре _SOLID_?

  
26. Какие средства обобщенного программирования есть в _Go_?  
  

-   Что я хочу оценить: знакомство с основными парадигмами современного программирования и границами их применимости в _Go_.
-   Самый популярный неправильный ответ: «Интерфейсы». Коллеги, интерфейсы ничего не обобщают (внезапно). Однако программисты, пришедшие в _Go_ с других языков, имеющих развитые средства обобщенного программирования, сильно тоскуют по ним и пытаются эмулировать эти самые средства с помощью интерфейсов. Создают при этом, простите за правду, кошмарных уродцев.
-   Наводящие вопросы: что такое _map-reduce_? Как его реализовать в _Go_? А без _interface{}_? А что такое кодогенерация и как ее можно использовать в этой задаче?

  
27. Какие технологические преимущества языка _Go_ вы можете назвать?  
  

-   Что я хочу оценить: глубину осознания кандидатом места языка _Go_ в современной разработке. Для каких задач _Go_ подходит идеально? Для каких не очень, но будет полезен? Преимущества существуют не сами по себе, а только в контексте задачи!
-   Самый популярный неправильный ответ: «Читабельность». Коллеги, читабельность — субъективная категория, она не может быть технологическим преимуществом. Это раз. Два — читабельность _Go_ довольно относительна. Килотонны _boilerplate_ обработки ошибок и ручной раскрутки стека читабельность ни в коем разе не увеличивают!
-   Наводящие вопросы: чем отличается _goroutine_ от _OS thread_? Как устроен сетевой ввод-вывод в _Go_?

  
28. Какие технологические недостатки языка _Go_ вы можете назвать?  
  

-   Что я хочу оценить: глубину осознания кандидатом места языка _Go_ в современной разработке. Для каких задач _Go_ совершенно не подходит?
-   Самый популярный неправильный ответ: «Отсутствие _generic types_». Я пробовал спрашивать на этом месте: «Для каких ваших текущих задач были бы полезны генерики?», — и ни разу не услышал ничего внятного. И не услышу — генерики критически важны для функциональных языков, а _Go_… Об этом ниже.
-   Наводящие вопросы: их миллион, но я задам один. Как превратить _[]io.ReadWriter_ в _[]io.Reader_?